using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MultiResolutionRL
{
    //Class will be used to create all the known and used equality comparers and keep them all in the same place. 
    //The benefit being that they can then be used off of one instance instead of having to be created individually

   static public class Comparer
    {
       public static StateClassComparer SCC = new StateClassComparer();
       public static IntArrayComparer IAC = new IntArrayComparer();
       public static ByteArrayComparer BAC = new ByteArrayComparer();
       public static DoubleArrayComparer DAC = new DoubleArrayComparer();
       public static ObjectComparer OC = new ObjectComparer();
        static object _x_Prime = null;
        static object _y_Prime = null;

        //Object Comparitor
        public class ObjectComparer : IEqualityComparer<Object>
        {
            public new bool Equals(object x, object y)
            {
                if (x.GetType() != y.GetType())
                    return false;
                if (x == null || y == null)
                    return false;
                _x_Prime = x;
                _y_Prime = y;
                switch ((x.GetType()).ToString())
                {
                    //Cyclic Logic, do not want to create SCC which creates a Object Comparer
                    case "MultiResolutionRL.StateClass": return SCC.Equals((StateClass)_x_Prime, (StateClass)_y_Prime);

                    case "System.Int32[]": return IAC.Equals((int[])_x_Prime, (int[])_y_Prime);
                    case "System.Int32": return ((int)_x_Prime == (int)_y_Prime);

                    case "System.Double": return ((double)_x_Prime == (double)_y_Prime);
                    case "System.Double[]": return DAC.Equals((double[])_x_Prime == (double[])_y_Prime);

                    case "System.Byte": return ((byte)_x_Prime == (byte)_y_Prime);
                    case "System.Byte[]": return BAC.Equals((byte[])_x_Prime == (byte[])_y_Prime);

                    default: Console.WriteLine("No Suitable Type comparer Found for type: {0}, Consider entering Comparer.cs, add a case",
                        (x.GetType()).ToString()); return false;
                }


                //find the approriate comparer for the the types

            }

            public int GetHashCode(object obj)
            {
                return (obj.ToString()).GetHashCode();
            }
        }
        public class ByteArrayComparer : IEqualityComparer<Byte[]>
        {
            public bool Equals(byte[] x, byte[] y)
            {
                if (x.Length != y.Length)
                    return false;
                foreach (byte b in x)
                    if (x[b] != y[b])
                        return false;
                return true;
            }

            public int GetHashCode(byte[] obj)
            {
                throw new NotImplementedException();
            }
        }
        public class DoubleArrayComparer : IEqualityComparer<double[]>
        {
            public bool Equals(double[] x, double[] y)
            {
                if (x.Length != y.Length)
                    return false;

                for (int d=0;d<x.Length;d++)
                    if (x[d] != y[d])
                        return false;
                return true;
            }

            public int GetHashCode(double[] obj)
            {
                throw new NotImplementedException();
            }
        }



        public class StateClassComparer : IEqualityComparer<StateClass>
        {
            
            //Compares, member by member for each of the stateClass.stateDicts if the stateFactors are the same
            public bool Equals(StateClass x, StateClass y)
            {
                if (x.Count() == y.Count())//Same Length
                {
                    foreach (string s in x.GetDescriptors())
                        if (y.FactorExist(s))
                        {
                            if (!(OC.Equals(x.GetStateFactor(s),y.GetStateFactor(s)) ))
                            {
                                return false;
                            }
                        }
                        else return false;
                }
                else return false;

                return true;
            }

            //Hash code can be generated by creating a string from each dictionary members value, 
            //Concatenate each value into a super string, then hash superstring, this should give 
            // a unique hash for the StateClass Obj.
            public int GetHashCode(StateClass obj)
            {
               string superString = "";
                object holder;
                List<string> descriptors = obj.GetDescriptors();
                foreach (string s in descriptors)
                {
                    holder = obj.GetStateFactor(s);

                    if ((holder.GetType()).IsArray) //If true will need to cast it to its specific type
                    {
                        Type hT = holder.GetType();                   
                        if (hT == typeof(int[]))
                            superString += string.Join("", (int[])holder);
                        else if (hT == typeof(double[]))
                            superString += string.Join("", (double[])holder);
                        else if (hT == typeof(byte[]))
                            superString += string.Join("", (byte[])holder);
                    }
                    else
                        superString += Convert.ToString(holder);
                }
                return superString.GetHashCode();
            }
            
        }
        [Serializable]
        public class IntArrayComparer : IEqualityComparer<int[]>
        {
            //Consider looking into doing some form Duff's device for accepting larger degree of states
            public bool Equals(int[] x, int[] y)
            {

                if (x == null || y == null || y.Length != x.Length)
                    return false;


                for (int i = 0; i < x.Length; i++) 
                {
                    if (x[i] != y[i])
                        return false;
                }
                return true;
            }

            public int GetHashCode(int[] obj)
            {
                int hash = 0;
                for (int i = 0; i < obj.Length; i++)
                {
                    int shift = 8 * i;
                    hash += obj[i] << shift;
                }
                return hash;
            }
        }
        public class GoalComparer<stateType, actionType> : IEqualityComparer<Goal<stateType, actionType>>
        {
            public bool Equals(Goal<stateType, actionType> x, Goal<stateType, actionType> y)
            {
                if (!x.stateComparer.Equals(x.goalState, y.goalState))
                    return false;
                if (!x.stateComparer.Equals(x.startState, y.startState))
                    return false;
                if (x.level != y.level)
                    return false;
                if (x.actionComparer.Equals(x.action, y.action))
                    return false;
                return true;
            }

            public int GetHashCode(Goal<stateType, actionType> obj)
            {
                return obj.stateComparer.GetHashCode(obj.goalState) + obj.stateComparer.GetHashCode(obj.startState);
            }
        }
    }


}
